# <span style="color:orange; font-size:17pt; font-weight:bold">2019 카카오 겨울 인턴 코테 3번 불량 사용자 자바(java)  풀이</span>
- LEVEL 3
- 문제 풀이 시간: 1시간
- [2019 카카오 겨울 인턴 코테 3번 불량 사용자](https://programmers.co.kr/learn/courses/30/lessons/64064)
<br><br>

## [티스토리 주소](https://hoho325.tistory.com/)
<br><br>

# <span style="color: red; font-size:15pt">문제 정리</span>
1. 가리고자 하는 문자 하나에 '*' 문자 하나를 사용한다.
2. 아이디 당 최소 하나의 '*'를 사용하여 불량 사용자를 표현하였다.
3. 제재 아이디: 불량 사용자 목록에 포함된 응모자 아이디
4. 불량 사용자 목록에 따른 제재 아이디 목록의 가지수가 몇 가지 인지 찾으시오
5. user_id 배열의 크기는 최대 8입니다.
6. user_id 각 원소의 길이는 최대 8입니다.
7. 응모자 아이디는 서로 중복되지 않으며, 알파벳 소문자와 숫자로만 이루어져 있습니다.
8. 불량 사용자 아이디 하나는 응모자 아이디 중 하나에 매핑됩니다.
<br><br>

# <span style="color: red; font-size:15pt">문제 풀이1 (visited)</span>
정확성 테스트만 놓고 봤을때 5문제 중에 푸는데 가장 오래걸린 문제였습니다.(다른분들은 어떠려나..)   
user_id도 많지 않고 banned_id도 많지 않기 때문에 각각 비교해나가며 완전탐색을 해서 구하면 됩니다.  
저는 정규표현식과 dfs를 이용해 모든 경우의 수를 따져주었습니다.  
<br>

visited 배열은 i번째 user_id를 제제 아이디에 매칭 시켰는지 확인하는 boolean 배열 입니다.
1. 재귀를 통해 pattern에 맞는 문자들을 user_id 중에서 선택해 나갑니다.
2. 우선 정규표현식을 쓰기 위해 '*' 문자를 '.'문자로 변환합니다. '.' 문자는 문자 하나를 의미합니다.
3. pattern matcher를 통해 pattern에 해당하는 문자 인지 판단합니다.
4. 해당하는 문자라면 길이도 같은지 확인하고 이미 다른 정규식에 의해서 banned_id로 체크하지 않은 경우(!visited[i]) 방문처리 하고 다음 banned_id를 찾기 위해 다시 dfs를 호출합니다.
5. 이렇게 반복하다가 n개의 매칭되는 제재 아이디를 모두 찾았다면 이전에 찾은 제재 아이디 목록과 같은 건지 확인하고 같지 않다면 count를 증가시켜 줍니다.
6. 이렇게 하면 모든 user_id에 대하여 하나씩 체크해 나가며 확인할 수 있습니다.
<br>

# <span style="color: red; font-size:15pt">bit masking</span>
먼저 bit masking에 대해서 간단히 알아보겠습니다.  

1. 집이 10채 있습니다. 그 중에서 1번집만 방문했다면 1번 bit만 1로 표시합니다. (0000000001)
2. 1번 집과 3번집을 방문하였습니다. 그러면 1번 비트와 3번 비트를 1로 표시하고 나머지는 방문하지 않았으므로 0으로 표시합니다. (0000000101)
3. visit >> i는 visit bit를 i만큼 오른쪽으로 shift 시킴을 의미합니다. 즉 i번째 bit가 맨 오른쪽으로 이동하게 됩니다.
    예를 들어 01011 >> 3 하게 되면 00001이 됩니다.
4. (visit >> i ) & 1을 하면 몇 번째 집을 방문 했는지 안했는지 알 수 있습니다.
    왜냐하면 3번에서 봤듰이 왼쪽의 연산을 하면 i번째 bit가 제일 오른쪽으로 이동합니다. 즉 1을 나타내는 자리입니다.
    거기에 1과 AND연산을 했으므로 i번째 bit가 1이었다면 맨 오른쪽 bit는 1이 되서 결과로 1이 나옵니다.
    즉 이 경우는 방문했음을 의미합니다.
    만약에 i번째 bit가 0이 었다면 제일 오른쪽 bit가 0외 되어 1(00001)와 AND 연산을 하게 되면 0이 되어서 방문하지 않았음을 알 수 있습니다.
5. (visit | 1 << i)을 통해 i번째 집을 방문했음을 표시할 수 있습니다.
    1 << i는 1을 i만큼 왼쪽으로 shift 시킴을 의미합니다.
    즉 i번째 집만 방문했음을 나타내도록 만들어 줍니다.
    여기에 지금까지 어디를 방문했는지 masking 해놓은 visit과 OR 연산을 하면 i번째 집을 방문했음을 나타낼 수 있습니다.
    예를들어 지금까지 1,3번 집을 방문했다면 visit은 00101 입니다.
    여기에 4번집을 새로 방문했다면 4번집을 방문 했음을 나타내기 위해서 i << 4를 하고(01000) 이 값과 OR 연산을 하면
    01101이 되서 1,3,4번째 집을 방문했음을 나타낼 수 있습니다.

# <span style="color: red; font-size:15pt">문제 풀이2 (bit masking)</span>
기본적인 로직은 위에 1번 풀이와 같습니다. 1번에서는 방문처리를 boolean 배열로 했다면 이 풀이는 bit를 이용하여 확인합니다.  
위에서 이야기한 bit masking 방식을 이해할수 있어야 합니다.  
1. 1번과 같은 방식으로 dfs를 이용합니다.
2. user_id 하나씩 정규식과 매칭 되는지 판단합니다.
3. 매칭 되고 방문하지 않았다면(불량 아이디와 매칭이 되지 않은 id라면) 방문 처리하고 다시 재귀를 통해 다른 불량 아이디와 user_id를 매칭 시킵니다.
4. n개의 제재 아이디를 모두 매칭시켰다면 set에 visit을 추가해줍니다.
    이 의미는 user_id 1,3번째를 매칭 시켰다면 00101이 되고 이게 바로 제제 목록을 나타내게 됩니다. 1번과 3번 아이디가 제재 목록에 있는 것입니다.
    중복되서 계산 되는 제재 아이디 목록을 막기 위해서 set에 저장하는 것입니다.
5. set의 size를 출력하면 그게 바로 제재아이디 목록의 개수가 됩니다.